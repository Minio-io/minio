/*
 * Minio Cloud Storage, (C) 2015, 2016, 2017 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cmd

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"io/ioutil"
	"math/big"
	"net"
	"os"
	"strings"
	"time"
)

// TLSPrivateKeyPassword is the environment variable which contains the password used
// to decrypt the TLS private key. It must be set if the TLS private key is
// password protected.
const TLSPrivateKeyPassword = "MINIO_CERT_PASSWD"

func loadX509KeyPair(certFile, keyFile string) (*tls.Certificate, []*x509.Certificate, error) {
	// If there is no private key and the auto-tls argument is present
	// create a new private key. If we create a new private key
	// we have to delete any existing certificate since there is no
	// chance that it matches our private key. If `MINIO_CERT_PASSWD`
	// is set the generated private key will be encrypted before it's
	// written to persistent persistent storage.
	if !isFile(keyFile) && globalCLIContext.AutoTLS != "" {
		if err := generatePrivateKey(keyFile); err != nil {
			return nil, nil, err
		}
		if isFile(certFile) { // delete any existing cert
			if err := os.Remove(certFile); err != nil {
				return nil, nil, err
			}
		}
	}
	// If there is no private key and no certificate we don't use TLS.
	// In case of auto-tls we've created the private key just before and
	// therefore there is at least a private key.
	if !isFile(certFile) && !isFile(keyFile) {
		return nil, nil, nil
	}

	// Now load the private key which was either generated by the user
	// or, in case of auto-tls, by us previously.
	privateKey, publicKey, privatePEMKey, err := loadPrivateKey(keyFile)
	if err != nil {
		return nil, nil, err
	}

	// If there is no certificate and the auto-tls argument is present
	// generate a new certificate. The auto-tls arguments are the
	// SANs (as comma-separated list).
	if !isFile(certFile) && globalCLIContext.AutoTLS != "" {
		if err = generateCertificate(certFile, privateKey, publicKey, strings.Split(globalCLIContext.AutoTLS, ",")); err != nil {
			return nil, nil, err
		}
	}

	// Load and decode the certificate which is expected to be a
	// valid PEM-encoded ANSI.1 string.
	rawCert, err := ioutil.ReadFile(certFile)
	if err != nil {
		return nil, nil, uiErrTLSNoCertificate(err)
	}
	certificates, err := decodeCertificates(rawCert)
	if err != nil {
		return nil, nil, err
	}

	// If the certificate has no intermediate or root CA certificates as parents
	// we assume it's a "self-signed" certificate. In case of auto-tls we check
	// wehether it's expired and if so renew it.
	if len(certificates) == 1 && globalCLIContext.AutoTLS != "" {
		x509Cert := certificates[0]
		if now := time.Now().UTC(); now.Before(x509Cert.NotBefore.UTC()) || now.After(x509Cert.NotAfter.UTC()) {
			if err = generateCertificate(certFile, privateKey, publicKey, strings.Split(globalCLIContext.AutoTLS, ",")); err != nil {
				return nil, nil, err
			}
			rawCert, err = ioutil.ReadFile(certFile)
			if err != nil {
				return nil, nil, uiErrTLSNoCertificate(err)
			}
			certificates, err = decodeCertificates(rawCert)
			if err != nil {
				return nil, nil, err
			}
		}
	}

	// Create a TLS certificate from the PEM certificate and the PEM private key.
	// If the private key does not match the certficate this will fail. That can happen
	// if e.g. the certificate was generated wrongly by external tools.
	certificate, err := tls.X509KeyPair(bytes.TrimSpace(rawCert), privatePEMKey)
	if err != nil {
		return nil, nil, uiErrTLSCertificateCreationFailed(err)
	}
	return &certificate, certificates, nil
}

// generatePrivateKey generates a new random private key and
// stores it at keyFile. If the env. variable `MINIO_CERT_PASSWD`
// is present it encrypts the private key before writing it to
// the file.
func generatePrivateKey(keyFile string) error {
	ecdsaKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return err // Should never happen - indicates out-of-entropy
	}
	rawKey, err := x509.MarshalECPrivateKey(ecdsaKey)
	if err != nil {
		return err // Should never happen - we created a well-formed ECDSA-key
	}
	var pemKey *pem.Block
	if password, ok := os.LookupEnv(TLSPrivateKeyPassword); ok {
		pemKey, err = x509.EncryptPEMBlock(rand.Reader, "ENCRYPTED PRIVATE KEY", rawKey, []byte(password), x509.PEMCipherAES256)
		if err != nil {
			return err // Should never happen - indicates out-of-entropy
		}
	} else {
		pemKey = &pem.Block{
			Type:  "PRIVATE KEY",
			Bytes: rawKey,
		}
	}
	return ioutil.WriteFile(keyFile, pem.EncodeToMemory(pemKey), 0600)
}

// generateCertificate generates a new X509 certifcate from the private and public key
// and stores it at certFile. The certificate has no (other) intermediate or root CA certificates.
// Therefore, no client will trust the certificate by default. Such a certificate is also
// referred as "self-signed" since it is singed by the private key belonging to the public key
// of the certificate.
// Such certificates should only be used for test, debug or development purposes.
func generateCertificate(certFile string, privateKey crypto.PrivateKey, publicKey crypto.PublicKey, hosts []string) error {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return err // This should never happen - indicates out-of-entropy.
	}

	// The hostname is optional debug information and set as the certificates organization unit.
	hostname, _ := os.Hostname()

	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization:       []string{"Minio +" + globalDeploymentID},
			OrganizationalUnit: []string{hostname},
		},

		NotAfter:  time.Now().AddDate(1, 0, 0), // By default create a certificate valid for 1 year.
		NotBefore: time.Now(),

		KeyUsage:              x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}
	for _, h := range hosts {
		if ip := net.ParseIP(h); ip != nil {
			template.IPAddresses = append(template.IPAddresses, ip)
		} else {
			template.DNSNames = append(template.DNSNames, h)
		}
	}
	cert, err := x509.CreateCertificate(rand.Reader, template, template, publicKey, privateKey)
	if err != nil {
		return uiErrTLSCertificateCreationFailed(nil)
	}
	return ioutil.WriteFile(certFile, pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: cert}), 0644)
}

// loadPRivateKey reads a private key from keyFile. It returns the private/public key pair
// and the PEM-encoded private key on success.
func loadPrivateKey(keyFile string) (crypto.PrivateKey, crypto.PublicKey, []byte, error) {
	rawKey, err := ioutil.ReadFile(keyFile)
	if err != nil {
		return nil, nil, nil, uiErrTLSNoPrivateKey(err)
	}
	pemKey, remaining := pem.Decode(bytes.TrimSpace(rawKey))
	if len(remaining) > 0 {
		return nil, nil, nil, uiErrTLSPaddedPrivateKey(nil)
	}
	if x509.IsEncryptedPEMBlock(pemKey) { // Try to decrypt the private key if it is encrypted.
		password, ok := os.LookupEnv(TLSPrivateKeyPassword)
		if !ok {
			return nil, nil, nil, uiErrTLSNoPassword(nil)
		}
		rawKey, err = x509.DecryptPEMBlock(pemKey, []byte(password))
		if err != nil {
			return nil, nil, nil, uiErrTLSWrongPassword(err)
		}
	} else {
		rawKey = pemKey.Bytes
	}

	// Try to parse the private key. It may be either encoded as
	// - PKCS1: only RSA keys
	// - EC:    only ECDSA keys
	// - PKCS8: either RSA or ECDSA keys
	//
	// Go supports only the P-160, P-224, P-256, P-384 and P-521 ECDSA curves.
	// However, we don't support the P-384 and P-521 curves because there are no
	// constant-time implementations (on all platforms).
	privateRSAKey, err := x509.ParsePKCS1PrivateKey(rawKey)
	if err == nil {
		rawKey = pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: rawKey})
		return privateRSAKey, privateRSAKey.Public(), rawKey, nil
	}

	privateECDSAKey, err := x509.ParseECPrivateKey(rawKey)
	if err == nil {
		if name := privateECDSAKey.PublicKey.Params().Name; name != "P-224" && name != "P-256" {
			return nil, nil, nil, uiErrTLSUnsupportedCurve(nil)
		}
		rawKey = pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: rawKey})
		return privateECDSAKey, privateECDSAKey.Public(), rawKey, nil
	}

	privateKey, err := x509.ParsePKCS8PrivateKey(rawKey)
	if err != nil {
		return nil, nil, nil, uiErrTLSUnsupportedKeyFormat(err)
	}
	switch privateKey := privateKey.(type) {
	default:
		return nil, nil, nil, uiErrTLSUnsupportedPKCS8Key(nil)
	case *ecdsa.PrivateKey:
		if name := privateECDSAKey.PublicKey.Params().Name; name != "P-224" && name != "P-256" {
			return nil, nil, nil, uiErrTLSUnsupportedCurve(nil)
		}
		rawKey = pem.EncodeToMemory(&pem.Block{Type: "PRIVATE KEY", Bytes: rawKey})
		return privateKey, privateKey.Public(), rawKey, nil
	case *rsa.PrivateKey:
		rawKey = pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: rawKey})
		return privateKey, privateKey.Public(), rawKey, nil
	}
}

// decode certificate parses raw PEM encoded X.509 certificates.
// It returns a non-empty list of certificates on success.
func decodeCertificates(rawCert []byte) ([]*x509.Certificate, error) {
	pemCert, remaining := pem.Decode(bytes.TrimSpace(rawCert))
	if len(remaining) > 0 {
		return nil, uiErrTLSPaddedCertificate(nil)
	}
	certs, err := x509.ParseCertificates(bytes.TrimSpace(pemCert.Bytes))
	if err != nil {
		return nil, uiErrTLSInvalidCertificate(err)
	}
	if len(certs) == 0 {
		return nil, uiErrTLSNoCertificate(nil)
	}
	return certs, nil
}

func fingerprintCert(cert *tls.Certificate) ([]byte, bool) {
	if cert == nil && len(cert.Certificate) != 1 {
		return nil, false
	}
	h := sha256.Sum256(cert.Certificate[0])
	return h[:], true
}

func fingerprintKey(cert *tls.Certificate) ([]byte, bool) {
	if cert == nil || len(cert.Certificate) != 1 {
		return nil, false
	}

	var (
		publicKeyDER []byte
		err          error
	)
	switch privateKey := cert.PrivateKey.(type) {
	default:
		return nil, false
	case *ecdsa.PrivateKey:
		publicKeyDER, err = x509.MarshalPKIXPublicKey(privateKey.Public())
	case *rsa.PrivateKey:
		publicKeyDER, err = x509.MarshalPKIXPublicKey(privateKey.Public())
	}
	if err != nil {
		return nil, false
	}
	h := sha256.Sum256(publicKeyDER)
	return h[:], true
}

func getRootCAs(certsCAsDir string) (*x509.CertPool, error) {
	rootCAs, _ := x509.SystemCertPool()
	if rootCAs == nil {
		// In some systems (like Windows) system cert pool is
		// not supported or no certificates are present on the
		// system - so we create a new cert pool.
		rootCAs = x509.NewCertPool()
	}

	fis, err := readDir(certsCAsDir)
	if err != nil {
		if err == errFileNotFound {
			err = nil // Return success if CA's directory is missing.
		}
		return rootCAs, err
	}

	// Load all custom CA files.
	for _, fi := range fis {
		// Skip all directories.
		if hasSuffix(fi, slashSeparator) {
			continue
		}
		caCert, err := ioutil.ReadFile(pathJoin(certsCAsDir, fi))
		if err != nil {
			return rootCAs, err
		}
		rootCAs.AppendCertsFromPEM(caCert)
	}
	return rootCAs, nil
}
